definitions:
  # the names of the functions - we use this to generate the code and to register the functions in
  # the javascript class
  ifunction: "js_${generator.prefix}_${class_name}_${func_name}"
  sfunction: "js_${generator.prefix}_${class_name}_${func_name}"
  constructor: "js_${generator.prefix}_${class_name}_constructor"
  ctor: "js_${generator.prefix}_${class_name}_ctor"
  public_field: "js_${generator.prefix}_${class_name}"
conversions:
  # some times you want to use a special native type when converting from spidermonkey to native
  # the most common case would be from JS-boolean to bool. Using "bool" will fail here since we
  # pass the address to the conversion method, and a JSBool is defined as an integer in spidermonkey
  native_types:
    short: "int32_t"
    "unsigned char": "uint32_t"
    "char": "int32_t"
    "@std::vector<std::basic_string.*>.>.>": "std::vector<std::string>"
    "@std::vector<int.*>.>": "std::vector<int>"
    "@cocos2d::Map<std::basic_string.*,": "cocos2d::Map<std::string,"
    "@std::map<std::basic_string.*,\\s*std::basic_string.*>": "std::map<std::string, std::string>"
  ns_map:
    "cocos2d::extension::": "cc."
    "cocos2d::ui::": "ccui."
    "cocos2d::": "cc."
    "spine::": "sp."
    "cocostudio::": "ccs."
    "cocosbuilder::": "cc."
    "CocosDenshion::": "cc."
  to_native:
    # jsval to int
    int: "ok &= jsval_to_int32(cx, ${in_value}, (int32_t *)&${out_value})"
    "unsigned int": "ok &= jsval_to_int32(cx, ${in_value}, (int32_t *)&${out_value})"
    "unsigned char": "ok &= jsval_to_int32(cx, ${in_value}, (int32_t *)&${out_value})"
    short: "ok &= jsval_to_int32(cx, ${in_value}, (int32_t *)&${out_value})"
    "unsigned short": "ok &= jsval_to_uint32(cx, ${in_value}, (uint32_t *)&${out_value})"
    char: "ok &= jsval_to_int32(cx, ${in_value}, (int32_t *)&${out_value})"
    bool: "ok &= jsval_to_bool(cx, ${in_value}, &${out_value})"
    float: "ok &= jsval_to_float(cx, ${in_value}, &${out_value})"
    double: "ok &= jsval_to_double(cx, ${in_value}, &${out_value})"
    long: "ok &= jsval_to_long(cx, ${in_value}, &${out_value})"
    "unsigned long": "ok &= jsval_to_ulong(cx, ${in_value}, &${out_value})"
    "ssize_t": "ok &= jsval_to_ssize(cx, ${in_value}, &${out_value})"
    # jsval has to be a TypedArray, a UInt32Array with 2 elements
    "long long": "ok &= jsval_to_long_long(cx, ${in_value}, &${out_value})"
    "std::string": "ok &= jsval_to_std_string(cx, ${in_value}, &${out_value})"
    "char*": "std::string ${out_value}_tmp; ok &= jsval_to_std_string(cx, ${in_value}, &${out_value}_tmp); ${out_value} = ${out_value}_tmp.c_str()"
    "Point": "ok &= jsval_to_ccpoint(cx, ${in_value}, &${out_value})"
    "Rect": "ok &= jsval_to_ccrect(cx, ${in_value}, &${out_value})"
    "Size": "ok &= jsval_to_ccsize(cx, ${in_value}, &${out_value})"
    "Color4B": "ok &= jsval_to_cccolor4b(cx, ${in_value}, &${out_value})"
    "Color4F": "ok &= jsval_to_cccolor4f(cx, ${in_value}, &${out_value})"
    "Color3B": "ok &= jsval_to_cccolor3b(cx, ${in_value}, &${out_value})"
    "Array*": "ok &= jsval_to_ccarray(cx, ${in_value}, &${out_value})"
    "Dictionary*": "ok &= jsval_to_ccdictionary(cx, ${in_value}, &${out_value})"
    "AffineTransform": "ok &= jsval_to_ccaffinetransform(cx, ${in_value}, &${out_value})"
    "FontDefinition":  "ok &= jsval_to_FontDefinition(cx, ${in_value}, &${out_value})"
    "String*": "std::string ${out_value}_tmp; ok &= jsval_to_std_string(cx, ${in_value}, &${out_value}_tmp); ${out_value} = cocos2d::String::create(${out_value}_tmp)"
    "@Vector<.*>": "ok &= jsval_to_ccvector(cx, ${in_value}, &${out_value})"
    "@Map<std::basic_string.*>": "ok &= jsval_to_ccmap_string_key(cx, ${in_value}, &${out_value})"
    "@map<std::basic_string.*,\\s*std::basic_string.*>": "ok &= jsval_to_std_map_string_string(cx, ${in_value}, &${out_value})"
    "Value": "ok &= jsval_to_ccvalue(cx, ${in_value}, &${out_value})"
    "ValueMap": "ok &= jsval_to_ccvaluemap(cx, ${in_value}, &${out_value})"
    "ValueMapIntKey": "ok &= jsval_to_ccvaluemapintkey(cx, ${in_value}, &${out_value})"
    "ValueVector": "ok &= jsval_to_ccvaluevector(cx, ${in_value}, &${out_value})"
    "@vector<std::basic_string.*>": "ok &= jsval_to_std_vector_string(cx, ${in_value}, &${out_value})"
    "@vector<int.*>": "ok &= jsval_to_std_vector_int(cx, ${in_value}, &${out_value})"
    "@vector<float.*>": "ok &= jsval_to_std_vector_float(cx, ${in_value}, &${out_value})"
    "Acceleration": "ok &= jsval_to_ccacceleration(cx, ${in_value}, &${out_value})"
    "Mat4": "ok &= jsval_to_matrix(cx, ${in_value}, &${out_value})"
    "Vec2": "ok &= jsval_to_vector2(cx, ${in_value}, &${out_value})"
    "Vec3": "ok &= jsval_to_vector3(cx, ${in_value}, &${out_value})"
    "Vec2*": "std::vector<cocos2d::Vec2> tempData;ok &= jsval_to_vector_vec2(cx, ${in_value}, &tempData);${out_value}=tempData.data()"
    "BlendFunc": "ok &= jsval_to_blendfunc(cx, ${in_value}, &${out_value})"
    "AnimationInfo": "ok &= jsval_to_animationInfo(cx, ${in_value}, &${out_value})"
    "Quaternion": "ok &= jsval_to_quaternion(cx, ${in_value}, &${out_value})"
    "Ray": "ok &= jsval_to_ray(cx, ${in_value}, &${out_value})"
    "TMXTileFlags_*": "uint32_t tempData; ${out_value}=(cocos2d::TMXTileFlags_*)&tempData; ok &= jsval_to_uint32(cx, ${in_value}, &tempData)"
    "ResourceData": "ok &= jsval_to_resourcedata(cx, ${in_value}, &${out_value})"
    "_ttfConfig": "ok &= jsval_to_TTFConfig(cx, ${in_value}, &${out_value})"
    "TTFConfig": "ok &= jsval_to_TTFConfig(cx, ${in_value}, &${out_value})"
    "ListenerID": "ok &= jsval_to_std_string(cx, ${in_value}, &${out_value})"
    "DownloaderHints": "ok &= jsval_to_DownloaderHints(cx, ${in_value}, &${out_value})"
    "b2Vec2": "ok &= jsval_to_b2Vec2(cx, ${in_value}, &${out_value})"
    "b2AABB": "ok &= jsval_to_b2AABB(cx, ${in_value}, &${out_value})"
    object: |
      do {
      ${($level + 1) * '    '}if (${in_value}.isNull()) { ${out_value} = nullptr; break; }
      ${($level + 1) * '    '}if (!${in_value}.isObject()) { ok = false; break; }
      ${($level + 1) * '    '}js_proxy_t *jsProxy;
      ${($level + 1) * '    '}JS::RootedObject tmpObj(cx, ${in_value}.toObjectOrNull());
      ${($level + 1) * '    '}jsProxy = jsb_get_js_proxy(cx, tmpObj);
      ${($level + 1) * '    '}${out_value} = (${ntype})(jsProxy ? jsProxy->ptr : NULL);
      ${($level + 1) * '    '}JSB_PRECONDITION2( ${out_value}, cx, false, "Invalid Native Object");
      ${($level + 0) * '    '}} while (0)

  from_native:
    # int to jsval
    int: "${out_value} = JS::Int32Value(${in_value})"
    "unsigned int": "${out_value} = JS::NumberValue(${in_value})"
    "unsigned short": "${out_value} = JS::NumberValue(${in_value})"
    "unsigned char": "${out_value} = JS::NumberValue(${in_value})"
    "long long": "ok &= long_long_to_jsval(cx, ${in_value}, &${out_value})"
    "@string\\s*&?": "ok &= std_string_to_jsval(cx, ${in_value}, &${out_value})"
    "@basic_string<char>\\s*&?": "ok &= std_string_to_jsval(cx, ${in_value}, &${out_value})"
    "std::string": "ok &= std_string_to_jsval(cx, ${in_value}, &${out_value})"
    "char*": "ok &= c_string_to_jsval(cx, ${in_value}, &${out_value})"
    bool: "${out_value} = JS::BooleanValue(${in_value})"
    float: "${out_value} = JS::NumberValue(${in_value})"
    double: "${out_value} = JS::DoubleValue(${in_value})"
    long: "ok &= long_to_jsval(cx, ${in_value}, &${out_value})"
    "unsigned long": "ok &= ulong_to_jsval(cx, ${in_value}, &${out_value})"
    "ssize_t": "ok &= ssize_to_jsval(cx, ${in_value}, &${out_value})"
    "Point": "ok &= ccpoint_to_jsval(cx, ${in_value}, &${out_value})"
    "Rect": "ok &= ccrect_to_jsval(cx, ${in_value}, &${out_value})"
    "Size": "ok &= ccsize_to_jsval(cx, ${in_value}, &${out_value})"
    "Color4B": "ok &= cccolor4b_to_jsval(cx, ${in_value}, &${out_value})"
    "Color4F": "ok &= cccolor4f_to_jsval(cx, ${in_value}, &${out_value})"
    "Color3B": "ok &= cccolor3b_to_jsval(cx, ${in_value}, &${out_value})"
    "Array*": "ok &= ccarray_to_jsval(cx, ${in_value}, &${out_value})"
    "Dictionary*": "ok &= ccdictionary_to_jsval(cx, ${in_value}, &${out_value})"
    "AffineTransform": "ok &= ccaffinetransform_to_jsval(cx, ${in_value}, &${out_value})"
    "FontDefinition": "ok &= FontDefinition_to_jsval(cx, ${in_value}, &${out_value})"
    "String*": "ok &= std_string_to_jsval(cx, ${in_value}->getCString(), &${out_value})"
    "@Vector<.*>": "ok &= ccvector_to_jsval(cx, ${in_value}, &${out_value})"
    "@Map<std::basic_string.*>": "ok &= ccmap_string_key_to_jsval(cx, ${in_value}, &${out_value})"
    "@map<std::basic_string.*,\\s*std::basic_string.*>": "ok &= std_map_string_string_to_jsval(cx, ${in_value}, &${out_value})"
    "Value": "ok &= ccvalue_to_jsval(cx, ${in_value}, &${out_value})"
    "ValueMap": "ok &= ccvaluemap_to_jsval(cx, ${in_value}, &${out_value})"
    "ValueMapIntKey": "ok &= ccvaluemapintkey_to_jsval(cx, ${in_value}, &${out_value})"
    "ValueVector": "ok &= ccvaluevector_to_jsval(cx, ${in_value}, &${out_value})"
    "@vector<std::basic_string.*>": "ok &= std_vector_string_to_jsval(cx, ${in_value}, &${out_value})"
    "@vector<int.*>": "ok &= std_vector_int_to_jsval(cx, ${in_value}, &${out_value})"
    "@vector<float.*>": "ok &= std_vector_float_to_jsval(cx, ${in_value}, &${out_value})"
    "Acceleration*": "ok &= ccacceleration_to_jsval(cx, *${in_value}, &${out_value})"
    "Mat4": "ok &= matrix_to_jsval(cx, ${in_value}, &${out_value})"
    "Vec2": "ok &= vector2_to_jsval(cx, ${in_value}, &${out_value})"
    "Vec3": "ok &= vector3_to_jsval(cx, ${in_value}, &${out_value})"
    "BlendFunc": "ok &= blendfunc_to_jsval(cx, ${in_value}, &${out_value})"
    "AnimationInfo": "ok &= animationInfo_to_jsval(cx, ${in_value}, &${out_value})"
    "spEventData*": "if (${in_value}) { ok &= speventdata_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spEvent*": "if (${in_value}) { ok &= spevent_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spBoneData*": "if (${in_value}) { ok &= spbonedata_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spBone*": "if (${in_value}) { ok &= spbone_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spSkeleton*": "if (${in_value}) { ok &= spskeleton_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spAttachment*": "if (${in_value}) { ok &= spattachment_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spSlotData*": "if (${in_value}) { ok &= spslotdata_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spSlot*": "if (${in_value}) { ok &= spslot_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spTimeline*": "if (${in_value}) { ok &= sptimeline_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spAnimationState*": "if (${in_value}) { ok &= spanimationstate_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spAnimation*": "if (${in_value}) { ok &= spanimation_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "spTrackEntry*": "if (${in_value}) { ok &= sptrackentry_to_jsval(cx, *${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "Quaternion": "ok &= quaternion_to_jsval(cx, ${in_value}, &${out_value})"
    "Uniform*": "if (${in_value}) { ok &= uniform_to_jsval(cx, ${in_value}, &${out_value}); } else { ${out_value} = JS::NullHandleValue; }"
    "ResourceData": "ok &= resourcedata_to_jsval(cx, ${in_value}, &${out_value})"
    "TouchEventType": "${out_value} = JS::Int32Value((int)${in_value})"
    "EventType": "${out_value} = JS::Int32Value((int)${in_value})"
    "ManifestAsset": "ok &= asset_to_jsval(cx, ${in_value}, &${out_value})"
    "@DownloadTask.*": "ok &= downloadTask_to_jsval(cx, ${in_value}, &${out_value})"
    "@shared_ptr<.*DownloadTask.*": "ok &= downloadTask_to_jsval(cx, *${in_value}, &${out_value})"
    "b2Vec2": "ok &= b2Vec2_to_jsval(cx, ${in_value}, &${out_value})"
    "b2Manifold*": "ok &= b2Manifold_to_jsval(cx, ${in_value}, &${out_value})"
    "b2AABB": "ok &= b2AABB_to_jsval(cx, ${in_value}, &${out_value})"
    object: |
      if (${in_value}) {
      ${($level + 1) * '    '}JS::RootedObject ${out_value}Obj(cx);
      ${($level + 1) * '    '}js_get_or_create_jsobject<${ntype.replace("*", "").replace("const ", "")}>(cx, (${ntype.replace("const ", "")})${in_value}, &${out_value}Obj);
      ${($level + 1) * '    '}${out_value} = JS::ObjectOrNullValue(${out_value}Obj);
      ${($level    ) * '    '}} else {
      ${($level + 1) * '    '}${out_value} = JS::NullHandleValue;
      ${($level    ) * '    '}}
